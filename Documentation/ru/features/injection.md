# Внедрение

Внедрение зависимостей бывает трех типов: через метод инициализации, через свойства и через любой другой метод. Библиотека поддерживает все 3 варианта внедрения зависимостей.
При этом есть мнение, что зависимости надо внедрять только через метод инициализации, а другим способом пользоваться в редких случаях, таких как - циклические зависимости или отсутствие возможности создавать объект самим.

## Внедрение через метод инициализации

Описание внедрения через метод инициализации происходит при регистрации нового компонента, но за место указания класса указывается его метод инициализации.
Рассмотрим пример:
```Swift
/// объявляем классы и протоколы

protocol Engine {}
protocol Wheel {}
protocol Body {}

class Car {
	private let engine: Engine
	private let wheel: Wheel
	private let body: Body
	init(engine: Engine, wheel: Wheel, body: Body) {
		self.engine = engine
		self.wheel = wheel
		self.body = body
	}
}

/// регистрация в контейнер
container.register(Car.init)
container.register(Car.init(engine:wheel:body:))
container.register { 
	return Car(engine: $0, wheel: $1, body: $2)
}

```
Ничего сложного.

И более подробно о каждом способе регистрации:

#### `container.register(Car.init)`
Самый простой способ регистрации. Работает если у класса есть единственный метод инициализации. Таким способом стоит пользоватся в двух случаях:
* Класс активно меняется, и менять каждый раз метод инициализации в двух местах не хочется.
* На проекте хочется сэкономить объем кода, и упросить его написание. При этом чтение кода становится более сложных, особенно если не работает xCode.

#### `container.register(Car.init(engine:wheel:body:))`
Наиболее предпочтительный способ регистрации. Работает даже если у класса есть несколько методов инициализации. Таким способом стоит пользоватся чаще всего, за исключением случаев когда надо внедрить объект не по типу. Если нужно внедрить объект по другому критерию, то есть третий случай.

#### `container.register { Car(engine: $0, wheel: $1, body: $2) }`
Универсальный способ регистрации. Имеет преимущество в том, что для него работает интеллисенс, и для большинства людей выглядит наиболее понятным. Но имеет и свой минус - надо проставлять цифры.
Помимо этого он может работать с [модификаторами](modificators.md) и с другими объектами, то есть можно внедрить объект не только по типу, но и по типу с тегом или внедрить сразу массив объект удовлетворяющих условию.
Например можно написать так:
```Swift
container.register {
	/// Внедряем:
	/// двигатель не зарегестрированный в DI
	/// все колеса соответствующие типу: Wheel
	/// rаркас, соответствующий тегу BMWBody
	Car(engine: BMWEngine(), wheels: many($0), body: by(tag: BMWBody.self, $1))
}
```

### ПРЕДУПРЕЖДЕНИЕ
!!! со swift4.0 из-за бага в компиляторе: https://bugs.swift.org/browse/SR-5112 в случае если надо при инициализации внедрять всего одну зависимость, то функция должна называться `register1` - то есть у функции есть суффикс `1`.

## Внедрение через свойства

Если внедрение через метод инициализации не подходит, то стоит использовать внедрение через свойства. А не подходить оно может по следующим причинам:
* Идеологическим - на проекте не принято внедрять так
* Историческим - уже написано много кода, который править долго
* Синтаксическим - наличие циклических зависимостей, или ViewController-ов создаваемых из xib/storyboard не дает возможности делать все с использованием методов инициализации.
* Временным - написать конструктор и прописать присваение переменных занимает больше времени чем написать всего одно свойство, хоть и является более грамотным.

При этом внедрение через свойство достаточно богато на синтаксис. Давайте рассмотрим все варианты:
```Swift
class Car {
	var engine: Engine!
	var wheels: [Wheel] = []
}

container.register(Car.init)
	/// При создании зависимостей ручками
	.injection { car in car.engine = BMWEngine() }
	.injection { $0.engine = BMWEngine() }
	/// При получении из DI контейнера
	.injection { car, engine in car.engine = engine }
	.injection { $0.engine = $1 }
	.injection(\Car.engine)
	.injection(\.engine)
	/// с модификаторами
	.injection { car wheel in car.wheels = many(wheel) }
	.injection { $0.wheels = many($1) }
	.injection(\Car.wheels) { wheel in many(wheel) }
	.injection(\.wheels) { many($0) }
	/// При необходимости указать другой тип
	.injection { $0.engine = $1 as OtherEngine }
	.injection(\Car.engine) { $0 as OtherEngine }
	/// При наличии цикла все теже варианты но с добавлением `cycle: true`
	.injection(cycle: true) { $0.engine = $1 }
	/// С указанием имени, все  теже варианты но с добавлением `name: "..."`
	.injection(name: "BMW") { $0.engine = $1 } /// deprecated(Лучше использовать модификаторы)
```
Скорей всего можно придумать еще комбинации, но все они вытекают из этих вариантов, которые на самом деле распадаются на 3:
1. `.injection(_ closure: @escaping (Impl) -> ())`
Вариант когда внедряемый объект создается на месте. Наиболее простой вариант, и редко используемый. Основное его использование или проставление общих констант (казалось бы при чем тут DI?), или добавление в уже существующих проект DI. Второй вариант более интересен, так как если проект большой а на нем нет DI, то скорей всего есть какойто аналог. И данное внедрение хорошо подходит, для переписывания проекта частями.
2. `.injection(name: String? = nil, cycle: Bool = false, _ closure: @escaping (Impl, Property) -> ())`
Старый вариант внедрения зависимостей, до swift4.0. Позволяет внедрить любой объект зарегестрированный в DI контейнере. Для чего нужен каждый параметер:
* `name` - является устаревшим способом, замененным на модификаторы. Нужно в случае если для одного и тогоже типа, надо иметь несколько вариантов компонента. например:
```Swift
container.register(Car.init)
	.as(Car.self, name: "BMW")
	.injection { $0.engine = BMWEngine() }
container.register(Car.init)
	.as(Car.self, name: "Eclipse")
	.injection { $0.engine = EclipseEngine() }
```
В этом случае при внедрении, можно указать одно из указанных имен, и получить интерисуемый экземпляр машины, но с разными двигателями.

!!! Причины отказа: строковые литералы не являются типо-безопасными, более того они подвержены опечаткам. На смену пришли [модификаторы](modificators.md). Да в отличии от имени они требуют чуть больше действий, но они имеет намного больше возможностей: можно пользоваться при инициализации, типо-безопасны, проверка валидности на стадии валидации, наличие области видимости. Все эти плюсы, в моем понимании, перевешивают их единственный минус - очевидность использования.

* `cycle` - является указанием, что данный граф зависимостей имеет цикл, и его нужно разорвать. На один цикл достаточно одного указания данного факта - это будет точкой разрыва, чтобы инициализации не ушла в бесконечный цикл. Наличие циклов проверяется при валидации, и если вы забудете указать, то библиотека сообщит об этом и предложит в определенном цикле указать данный факт.

!!! Стоит учесть: Если при регистрации указывается много внедрений через свойства, то все они будут внедрятся строго в указанном порядке, за исключением циклических внедрений - их момент внедрения сложно пред угадать. Единственное что можно сказать наверняка - циклические внедрения будут внедрятся после всех не циклических и также по порядку.

* `closure` - метод описывающий способ внедрения. На вход принимает объект в который внедряемся и объект который будет внедрен. Ваша задача присвоить объект, так как swift до 4 версии не умел это делать каким либо способом.

!!! Lifehack: Не рекомендуется, но на самом деле в `closure` можно делать любые другие действия. Но лучше для этих целей использовать отдельный метод `postInit`, который исполняется после всех внедрений.

3. `injection(name: String? = nil, cycle: Bool = false, _ keyPath: ReferenceWritableKeyPath<Impl, P>, _ modificator: @escaping (Property) -> P)`
Улучшенный вариант предыдущего доступный со swift4.0. улучшение касается как синтаксиса - он становится короче и понятней, так и возможностей: при таком внедрении свойство может иметь область видимости меньше, чем в прошлом случае:
```Swift
class Car {
	/// Прошлое способ не имеет возможности изменить свойство при таком модификаторе доступа
	/// Начиная со swift4.0 благодаря keyPath достаточно только знать о свойстве, без возможности модифицировать
	private(set) var engine: Engine!
}
```
Во всех остальных отношениях этот способ эквивалентен предыдущему. Стоит только уточнить про наличие еще одного параметра `modificator`:
`modificator` нужен для добавления модификаторов. В случае если нам нужно получить объект с использованием модификатора, к примеру `many`, то это можно легко дописать в конце, например как это было сделано тут:
```Swift
.injection(\.wheels) { many($0) }
```

## Внедрение через метод

Последний способ внедрения. Мало популярный, и мало отличающийся от внедрения через свойства, кроме как того что происходит внедрение нескольких зависимостей одновременно. Более того такой способ имеет меньший функционал.
```Swift
container.register(Car.init)
	.injection { $0.setup(engine: $1, wheels: many($2), body: $3) }
```
Как и с методом инициализации, такой способ не умеет внедрять по имени, и не поддерживаемт разрыв циклов.

## После инициализации

После полной инициализации объекта, с внедрением всех зависимостей, в том числе и циклических, вызывается еще один метод `postInit`. По умолчанию он отсутствует, но если вам нужно сделать какие-нибудь дополнительные методы после полной инициализации метода, вы можете его определить:
```Swift
container.register(Car.init)
	.injection(\.engine)
	.injection(\.wheels) { many($0) }
	.injection(\.body)
	.postInit { car in
		car.move(to: Moscow.location)
	}
```


